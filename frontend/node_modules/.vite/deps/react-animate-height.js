import {
  require_react
} from "./chunk-ZLZLTJQL.js";
import {
  __toESM
} from "./chunk-2LSFTFF7.js";

// node_modules/react-animate-height/dist/esm/index.js
var import_react = __toESM(require_react());
var __rest = function(s, e) {
  var t = {};
  for (var p in s)
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
      t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
};
function isNumber(n) {
  const number = parseFloat(n);
  return !isNaN(number) && isFinite(number);
}
function isPercentage(height) {
  return typeof height === "string" && height[height.length - 1] === "%" && isNumber(height.substring(0, height.length - 1));
}
function hideContent(element, height) {
  if (height === 0 && (element === null || element === void 0 ? void 0 : element.style)) {
    element.style.display = "none";
  }
}
function showContent(element, height) {
  if (height === 0 && (element === null || element === void 0 ? void 0 : element.style)) {
    element.style.display = "";
  }
}
var ANIMATION_STATE_CLASSES = {
  animating: "rah-animating",
  animatingUp: "rah-animating--up",
  animatingDown: "rah-animating--down",
  animatingToHeightZero: "rah-animating--to-height-zero",
  animatingToHeightAuto: "rah-animating--to-height-auto",
  animatingToHeightSpecific: "rah-animating--to-height-specific",
  static: "rah-static",
  staticHeightZero: "rah-static--height-zero",
  staticHeightAuto: "rah-static--height-auto",
  staticHeightSpecific: "rah-static--height-specific"
};
function getStaticStateClasses(animationStateClasses, height) {
  return [
    animationStateClasses.static,
    height === 0 && animationStateClasses.staticHeightZero,
    height > 0 && animationStateClasses.staticHeightSpecific,
    height === "auto" && animationStateClasses.staticHeightAuto
  ].filter((v) => v).join(" ");
}
var AnimateHeight = (_a) => {
  var { animateOpacity = false, animationStateClasses = {}, applyInlineTransitions = true, children, className = "", contentClassName, delay: userDelay = 0, duration: userDuration = 500, easing = "ease", height, onHeightAnimationEnd, onHeightAnimationStart, style } = _a, props = __rest(_a, ["animateOpacity", "animationStateClasses", "applyInlineTransitions", "children", "className", "contentClassName", "delay", "duration", "easing", "height", "onHeightAnimationEnd", "onHeightAnimationStart", "style"]);
  const prevHeight = (0, import_react.useRef)(height);
  const contentElement = (0, import_react.useRef)(null);
  const animationClassesTimeoutID = (0, import_react.useRef)();
  const timeoutID = (0, import_react.useRef)();
  const stateClasses = (0, import_react.useRef)(Object.assign(Object.assign({}, ANIMATION_STATE_CLASSES), animationStateClasses));
  const isBrowser = typeof window !== "undefined";
  const prefersReducedMotion = (0, import_react.useRef)(isBrowser && window.matchMedia ? window.matchMedia("(prefers-reduced-motion)").matches : false);
  const delay = prefersReducedMotion.current ? 0 : userDelay;
  const duration = prefersReducedMotion.current ? 0 : userDuration;
  let initHeight = height;
  let initOverflow = "visible";
  if (typeof initHeight === "number") {
    initHeight = height < 0 ? 0 : height;
    initOverflow = "hidden";
  } else if (isPercentage(initHeight)) {
    initHeight = height === "0%" ? 0 : height;
    initOverflow = "hidden";
  }
  const [currentHeight, setCurrentHeight] = (0, import_react.useState)(initHeight);
  const [overflow, setOverflow] = (0, import_react.useState)(initOverflow);
  const [useTransitions, setUseTransitions] = (0, import_react.useState)(false);
  const [animationStateClassNames, setAnimationStateClassNames] = (0, import_react.useState)(getStaticStateClasses(stateClasses.current, height));
  (0, import_react.useEffect)(() => {
    hideContent(contentElement.current, currentHeight);
  }, []);
  (0, import_react.useEffect)(() => {
    if (height !== prevHeight.current && contentElement.current) {
      showContent(contentElement.current, prevHeight.current);
      contentElement.current.style.overflow = "hidden";
      const contentHeight = contentElement.current.offsetHeight;
      contentElement.current.style.overflow = "";
      const totalDuration = duration + delay;
      let newHeight;
      let timeoutHeight;
      let timeoutOverflow = "hidden";
      let timeoutUseTransitions;
      const isCurrentHeightAuto = prevHeight.current === "auto";
      if (typeof height === "number") {
        newHeight = height < 0 ? 0 : height;
        timeoutHeight = newHeight;
      } else if (isPercentage(height)) {
        newHeight = height === "0%" ? 0 : height;
        timeoutHeight = newHeight;
      } else {
        newHeight = contentHeight;
        timeoutHeight = "auto";
        timeoutOverflow = void 0;
      }
      if (isCurrentHeightAuto) {
        timeoutHeight = newHeight;
        newHeight = contentHeight;
      }
      const newAnimationStateClassNames = [
        stateClasses.current.animating,
        (prevHeight.current === "auto" || height < prevHeight.current) && stateClasses.current.animatingUp,
        (height === "auto" || height > prevHeight.current) && stateClasses.current.animatingDown,
        timeoutHeight === 0 && stateClasses.current.animatingToHeightZero,
        timeoutHeight === "auto" && stateClasses.current.animatingToHeightAuto,
        timeoutHeight > 0 && stateClasses.current.animatingToHeightSpecific
      ].filter((v) => v).join(" ");
      const timeoutAnimationStateClasses = getStaticStateClasses(stateClasses.current, timeoutHeight);
      setCurrentHeight(newHeight);
      setOverflow("hidden");
      setUseTransitions(!isCurrentHeightAuto);
      setAnimationStateClassNames(newAnimationStateClassNames);
      clearTimeout(timeoutID.current);
      clearTimeout(animationClassesTimeoutID.current);
      if (isCurrentHeightAuto) {
        timeoutUseTransitions = true;
        timeoutID.current = setTimeout(() => {
          setCurrentHeight(timeoutHeight);
          setOverflow(timeoutOverflow);
          setUseTransitions(timeoutUseTransitions);
          onHeightAnimationStart === null || onHeightAnimationStart === void 0 ? void 0 : onHeightAnimationStart(timeoutHeight);
        }, 50);
        animationClassesTimeoutID.current = setTimeout(() => {
          setUseTransitions(false);
          setAnimationStateClassNames(timeoutAnimationStateClasses);
          hideContent(contentElement.current, timeoutHeight);
          onHeightAnimationEnd === null || onHeightAnimationEnd === void 0 ? void 0 : onHeightAnimationEnd(timeoutHeight);
        }, totalDuration);
      } else {
        onHeightAnimationStart === null || onHeightAnimationStart === void 0 ? void 0 : onHeightAnimationStart(newHeight);
        timeoutID.current = setTimeout(() => {
          setCurrentHeight(timeoutHeight);
          setOverflow(timeoutOverflow);
          setUseTransitions(false);
          setAnimationStateClassNames(timeoutAnimationStateClasses);
          if (height !== "auto") {
            hideContent(contentElement.current, newHeight);
          }
          onHeightAnimationEnd === null || onHeightAnimationEnd === void 0 ? void 0 : onHeightAnimationEnd(newHeight);
        }, totalDuration);
      }
    }
    prevHeight.current = height;
    return () => {
      clearTimeout(timeoutID.current);
      clearTimeout(animationClassesTimeoutID.current);
    };
  }, [height]);
  const componentStyle = Object.assign(Object.assign({}, style), { height: currentHeight, overflow: overflow || (style === null || style === void 0 ? void 0 : style.overflow) });
  if (useTransitions && applyInlineTransitions) {
    componentStyle.transition = `height ${duration}ms ${easing} ${delay}ms`;
    if (style === null || style === void 0 ? void 0 : style.transition) {
      componentStyle.transition = `${style.transition}, ${componentStyle.transition}`;
    }
    componentStyle.WebkitTransition = componentStyle.transition;
  }
  const contentStyle = {};
  if (animateOpacity) {
    contentStyle.transition = `opacity ${duration}ms ${easing} ${delay}ms`;
    contentStyle.WebkitTransition = contentStyle.transition;
    if (currentHeight === 0) {
      contentStyle.opacity = 0;
    }
  }
  const hasAriaHiddenProp = typeof props["aria-hidden"] !== "undefined";
  const ariaHidden = hasAriaHiddenProp ? props["aria-hidden"] : height === 0;
  return import_react.default.createElement(
    "div",
    Object.assign({}, props, { "aria-hidden": ariaHidden, className: `${animationStateClassNames} ${className}`, style: componentStyle }),
    import_react.default.createElement("div", { className: contentClassName, style: contentStyle, ref: contentElement }, children)
  );
};
var esm_default = AnimateHeight;
export {
  esm_default as default
};
//# sourceMappingURL=react-animate-height.js.map
